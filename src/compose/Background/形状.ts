import { getCtxSize, random, randomColor } from "./util"

interface 风力 {
    当前风力: [ number, number ]
    目标风力: [ number, number ]
    风力范围: [[ number, number ], [ number, number ]]
}

interface Shape {
    x: number
    y: number
    type: "圆形" | "星星" | "花朵" | "雪花" | "小兔" | "茶杯"
    size: number
    color: string
    rotation: number
    rotationSpeed: number
    
    个体风力: 风力
}

const shapes: Shape[] = []

const 全局风力: 风力 = {
    当前风力: [ 0, 0 ],
    目标风力: [ 0, 0 ],
    风力范围: [
        [ -0.5, 1 ],   // X轴范围
        [ -0, -2 ]   // Y轴范围 (负数向上)
    ]
}

// 辅助函数：缓动逼近
const lerp = (start: number, end: number, t: number) => {
    return start * (1 - t) + end * t
}

const updateWind = (wind: 风力) => {
    // 缓动更新当前风力
    wind.当前风力[0] = lerp(wind.当前风力[0], wind.目标风力[0], 0.005)
    wind.当前风力[1] = lerp(wind.当前风力[1], wind.目标风力[1], 0.005)

    // 检查是否到达目标，如果到达则随机新目标
    if (Math.abs(wind.当前风力[0] - wind.目标风力[0]) < 0.1 && 
        Math.abs(wind.当前风力[1] - wind.目标风力[1]) < 0.1) {
        
        wind.目标风力[0] = random(wind.风力范围[0][0], wind.风力范围[0][1])
        wind.目标风力[1] = random(wind.风力范围[1][0], wind.风力范围[1][1])
    }
}

// 初始化风力目标
const initWind = (wind: 风力) => {
    wind.目标风力[0] = random(wind.风力范围[0][0], wind.风力范围[0][1])
    wind.目标风力[1] = random(wind.风力范围[1][0], wind.风力范围[1][1])
    wind.当前风力[0] = wind.目标风力[0]
    wind.当前风力[1] = wind.目标风力[1]
}

// 计时器引用，用于清理
let emitTimer: number | null = null
let updateTimer: number | null = null

export const init形状 = (ctx: CanvasRenderingContext2D) => {
    // 清理旧的定时器和数据
    if (emitTimer) clearInterval(emitTimer)
    if (updateTimer) clearInterval(updateTimer)
    shapes.length = 0

    // 重置全局风力
    initWind(全局风力)

    // 启动发射器：每 300ms 发射一个新粒子
    emitTimer = window.setInterval(() => {
        emitShape(ctx)
    }, 800)

    // 启动更新器：每 16ms (约60fps) 更新一次所有粒子位置
    updateTimer = window.setInterval(() => {
        update(ctx)
    }, 15)
}

// 发射单个粒子
const emitShape = (ctx: CanvasRenderingContext2D) => {
    const [ width, height ] = getCtxSize(ctx)

    const type = ["圆形", "星星", "花朵", "雪花", "小兔", "茶杯"][Math.floor(random(0, 6))] as any
    
    const newShape: Shape = {
        x: random(-100, width),
        y: height + 60, // 从屏幕底部下方发射
        type: type,
        size: random(30, 60),
        color: randomColor(),
        rotation: random(0, Math.PI * 2),
        rotationSpeed: random(-0.015, 0.015),
        
        个体风力: {
            当前风力: [ 0, 0 ],
            目标风力: [ 0, 0 ],
            风力范围: [
                [ -0.8, 0.8 ], // 个体X轴范围
                [ -0.5, 0.5 ]  // 个体Y轴范围
            ]
        }
    }
    
    initWind(newShape.个体风力)
    
    shapes.push(newShape)
}

// 更新所有粒子状态
const update = (ctx: CanvasRenderingContext2D) => {
    const [ width, height ] = getCtxSize(ctx)

    // 1. 更新全局风力
    updateWind(全局风力)

    // 倒序遍历以便安全移除
    for (let i = shapes.length - 1; i >= 0; i--) {
        const shape = shapes[i]
        
        // 2. 更新个体风力
        updateWind(shape.个体风力)

        // 3. 更新位置
        // 最终位置 += 全局风力 + 个体风力
        shape.x += 全局风力.当前风力[0] + shape.个体风力.当前风力[0]
        shape.y += 全局风力.当前风力[1] + shape.个体风力.当前风力[1]
        
        shape.rotation += shape.rotationSpeed

        // 边界检查
        if (shape.y < -100) {
            shapes.splice(i, 1)
            continue
        }
        
        if (shape.x < -150 || shape.x > width + 150) {
            shapes.splice(i, 1)
        }
    }
}

// 只负责绘制
export const draw形状 = (ctx: CanvasRenderingContext2D) => {
    shapes.forEach(shape => {
        ctx.save()
        ctx.translate(shape.x, shape.y)
        ctx.rotate(shape.rotation)
        ctx.fillStyle = shape.color
        ctx.globalAlpha = 0.5

        ctx.beginPath()

        switch (shape.type) {
            case "圆形":
                // 小圆点/泡泡
                ctx.arc(0, 0, shape.size / 2, 0, Math.PI * 2)
                ctx.fill()
                // 加个高光让它像泡泡
                ctx.beginPath()
                ctx.fillStyle = "rgba(255,255,255,0.6)"
                ctx.arc(-shape.size / 6, -shape.size / 6, shape.size / 8, 0, Math.PI * 2)
                ctx.fill()
                break

            case "星星":
                // 圆角四角星
                const r = shape.size / 2
                const inset = 0.45
                ctx.moveTo(0, -r)
                for (let i = 0; i < 8; i++) {
                    const angle = ((i + 1) * Math.PI) / 4 - Math.PI / 2
                    const radius = (i % 2 === 0) ? r * inset : r
                    // 使用简单的直线连接，保持几何感但因为size变大，圆角会显得太圆，
                    // 这里我们做微小的圆角处理
                    const nextAngle = ((i + 2) * Math.PI) / 4 - Math.PI / 2
                    const nextRadius = ((i + 1) % 2 === 0) ? r * inset : r

                    // 简单的圆角星：在顶点处使用 arcTo 或者贝塞尔
                    // 这里为了保持风格统一，还是用简单的直线，但是可以通过 lineJoin="round" (已设置) 来获得圆角
                    ctx.lineTo(Math.cos(angle) * radius, Math.sin(angle) * radius)
                }
                ctx.closePath()
                ctx.fill()
                break

            case "花朵":
                const flowerPath = new Path2D("M72.8326,406.8478a2.7805,2.7805,0,0,0-.4356.7811c3.3013-1.76,11.51-5.2134,19.4771-.502a20.1678,20.1678,0,0,0-2.8181,6.2906c-.29,1.3571-.2539,3.9172-1.7754,4.8773a3.4129,3.4129,0,0,1-3.0142.43c-3.61-1.5061-5.1587-5.31-10.71-7.3129a2.7638,2.7638,0,0,0-.8777-.1729c2.6941,2.596,8.5155,9.3362,6.4961,18.3687a20.1629,20.1629,0,0,0-6.8532-.7364c-1.3807.1433-3.8042.9691-5.1873-.1814a3.4131,3.4131,0,0,1-1.34-2.7339c.317-3.8988,3.4566-6.5471,3.6455-12.4458a2.773,2.773,0,0,0-.1079-.8916c-1.63,3.3561-6.2322,10.9856-15.4612,11.858a20.1566,20.1566,0,0,0-1.4175-6.7454c-.5627-1.2688-2.0971-3.3186-1.43-4.99a3.4124,3.4124,0,0,1,2.1861-2.1192c3.8059-.9035,7.2946,1.2641,12.9631-.379a2.7694,2.7694,0,0,0,.8147-.3782c-3.6953-.5127-12.3738-2.5322-16.0554-11.04a20.1615,20.1615,0,0,0,5.9773-3.4325c1.0327-.9274,2.508-3.02,4.3032-2.9024a3.4124,3.4124,0,0,1,2.6909,1.4242c2.0354,3.34,1.0523,7.3284,4.3665,12.2115a2.7673,2.7673,0,0,0,.6084.6557c-.6536-3.6836-1.4014-12.5581,5.5412-18.6787a20.1645,20.1645,0,0,0,5.1111,4.6236c1.201.6958,3.6471,1.4521,4.09,3.1958a3.4117,3.4117,0,0,1-.523,3C80.5494,401.89,76.4527,402.1868,72.8326,406.8478Z")
                
                // SVG 路径的原始中心点大约在 (72, 406) 附近，且尺寸较大
                // 我们需要将其缩放并移动到 (0, 0) 以便旋转和定位
                // 通过观察路径数据，大概估算边界框或者直接尝试偏移
                // 为了简单起见，我们先缩放，然后通过 translate 调整中心
                
                // 原始 SVG 的 bounding box 大概是 40x40 左右，位置在 (50, 390) 附近
                // 我们直接缩放 path，使其适配 shape.size
                
                const scale = shape.size / 40 // 假设原始大小约为 40
                ctx.scale(scale, scale)
                ctx.translate(-72, -406) // 尝试将中心移回原点
                ctx.fill(flowerPath)
                break
                
            case "雪花":
                const snowPath = new Path2D("M90.781,206.5853a11.3063,11.3063,0,0,0-.685-2.8915,9.0445,9.0445,0,0,1-.76-2.6609.588.588,0,0,1,.5311-.6091c1.2189,0,3.425,4.1075,5.5541,4.1075a2.3043,2.3043,0,0,0,2.3566-2.2827c0-3.5744-6.9969-2.204-6.9969-3.8791,0-1.6733,6.9969-.3043,6.9969-3.8793a2.3036,2.3036,0,0,0-2.3566-2.28c-2.1291,0-4.3352,4.1062-5.5541,4.1062a.5864.5864,0,0,1-.5311-.6074,9.0642,9.0642,0,0,1,.76-2.663,11.2763,11.2763,0,0,0,.685-2.8893,1.9344,1.9344,0,0,0-2.0543-2.13,2.0108,2.0108,0,0,0-2.2047,2.13,9.0824,9.0824,0,0,0,.76,2.8893,11.4438,11.4438,0,0,1,.685,2.663.587.587,0,0,1-.5332.6074c-1.2161,0-3.4221-4.1062-5.552-4.1062a2.3048,2.3048,0,0,0-2.3579,2.28c0,3.575,6.9982,2.206,6.9982,3.8793,0,1.6751-6.9982.3047-6.9982,3.8791a2.3055,2.3055,0,0,0,2.3579,2.2827c2.13,0,4.3359-4.1075,5.552-4.1075a.5886.5886,0,0,1,.5332.6091,11.4169,11.4169,0,0,1-.685,2.6609,9.1047,9.1047,0,0,0-.76,2.8915,2.0107,2.0107,0,0,0,2.2047,2.13A1.9344,1.9344,0,0,0,90.781,206.5853Z")
                
                // 雪花 SVG 的中心大约在 (89, 196) 附近
                // 原始大小约为 20x20
                const snowScale = shape.size / 20
                ctx.scale(snowScale, snowScale)
                ctx.translate(-89, -196)
                ctx.fill(snowPath)
                break
                
            case "小兔":
                const rabbitPath = new Path2D("M79.5553,11.9412c.3976-2.55,3.28-3.8832,4.5566-3.9235-.36-1.3825-.4437-7.3194,1.2888-8.0167,0,0,1.4746-.21,1.01,5.4564,0,0-.3628,1.3683-.7452,2.4857l1.2237.3045C90.2.8952,93.3179,1.763,93.3179,1.763,95.5162,3.23,88.75,9.6044,88.75,9.6044c.7794,1.6649-.0047,4.4333-.0047,4.4333a6.9292,6.9292,0,0,1,5.1414,1.5847c1.9692-1.338,2.6853.4,2.6853.4.4938,1.5406-1.3209,2.1548-1.3209,2.1548,1.61,2.2078.9864,3.1414.6228,3.5334-.4618.38-2.3774-.992-2.3774-.992-1.15-.2244-2.0668-.8981-3.35-.9679A15.6428,15.6428,0,0,0,82.6327,21.29c-1.3145.651-2.2764.931-2.7959.5212-.6274-2.1495,3.3809-5.465,3.3809-5.465.5436-.4938-.3958-.6454-.3958-.6454A3.4075,3.4075,0,0,1,79.5553,11.9412")
                
                // 小兔 SVG 的边界框大概在 x=79, y=0 到 x=96, y=22 之间
                // 中心点大约在 (87, 11) 附近
                // 尺寸大约是 17x22
                
                const rabbitScale = shape.size / 20
                ctx.scale(rabbitScale, rabbitScale)
                ctx.translate(-87, -11)
                ctx.fill(rabbitPath)
                break
                
            case "茶杯":
                // 仅保留茶杯部分（第二段路径），去除了前面的钩子部分
                const cupPath = new Path2D("M26.8149,169.8222c-.1122.1206-.2281.2387-.3458.3636-.66.69.0651,2.444,1.6093,3.9216,1.5477,1.4768,3.3364,2.115,3.9958,1.4264.1147-.1225.23-.2431.345-.3623a4.7382,4.7382,0,0,0,1.9415-.414c1.5876.55,3.5729.8505,5.1528-.8053a2.2386,2.2386,0,0,0,.69-1.7267,3.02,3.02,0,0,0-.9358-1.8337c.2195-.2306.4379-.4579.6571-.6887.662-.69-.5906-2.9583-2.802-5.0678-2.207-2.1072-4.5315-3.2567-5.1924-2.5652-.8045.8449-1.5228,1.592-2.5091,2.6254C28.7578,165.3913,26.6858,167.31,26.8149,169.8222Zm8.73,4.245a12.7823,12.7823,0,0,0,1.8746-1.74c.4294-.4487.804-.8422,1.1629-1.2183a2.0037,2.0037,0,0,1,.6244,1.1864,1.2752,1.2752,0,0,1-.41.9686A3.1981,3.1981,0,0,1,35.5449,174.0672Zm-2.8142-11.2364c.3677-.3894,2.1039.6629,3.87,2.351,1.768,1.6882,2.9015,3.3715,2.53,3.7623-.37.3874-2.1061-.6651-3.8719-2.3523C33.4866,164.9036,32.36,163.2162,32.7307,162.8308Z")
                
                // 茶杯 SVG 的中心大约在 (32, 168) 附近
                // 尺寸大约是 15x15
                
                const cupScale = shape.size / 20
                ctx.scale(cupScale, cupScale)
                ctx.translate(-32, -168)
                ctx.fill(cupPath)
                break
        }

        ctx.restore()
    })
}
